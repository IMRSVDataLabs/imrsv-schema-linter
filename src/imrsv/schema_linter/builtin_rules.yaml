# See also:
# - https://wiki.postgresql.org/wiki/Don't_Do_This
# - https://www.schemacrawler.com/lint.html

---
root: false
rules:
  no-trust-auth-over-ip:
    severity: error
    title: Trust authentication over inet
    labels:
      - server
      - security
      - major
    comment: |
      Seriously, don't do this, even if ever so inconvenient. Make it
      convenient instead.
    query: |
      SELECT *
      FROM pg_catalog.pg_hba_file_rules
      WHERE auth_method = 'trust' AND type <> 'local'
      ORDER BY line_number

  insecure-auth-method:
    severity: error
    title: Insecure authentication method
    labels:
      - server
      - security
      - major
    comment: |
      This has all been well known since between the 1980s and the 2010s
      depending on the auth_method. Also, instead of trust, you can just
      sudo -u postgres psql, or whatever your local user is if you really
      depend on that.
    query: |
      SELECT p.*, v.why
      FROM pg_catalog.pg_hba_file_rules AS p
      JOIN (VALUES ('md5', 'long known insecure hash'),
                   ('password',
                    'plaintext password, uuuum, not since 1980s crypt()'),
                   ('trust',
                    'Blindly trusting, i.e., not authenticating; at least use'
                    ' peer for local'),
                   ('ident',
                    'authenticating users by their IP:port alone (spoofable,'
                    ' replayable, not secret)'))
        AS v(auth_method, why)
        ON p.auth_method = v.auth_method
      ORDER BY line_number

  windows-auth:
    severity: warning
    title: Windows authentication (SSPI)
    labels:
      - server
      - security
      - controversial
    comment: |
      Why the heck are you using Windows in the first place?
    query: |
      SELECT *
      FROM pg_catalog.pg_hba_file_rules
      WHERE auth_method = 'sspi'
      ORDER BY line_number

  server-itself-authentication:
    severity: notice
    title: Server itself authentication rather than external or in-PG
    labels:
      - server
      - security
      - minor
      - controversial
    comment: |
      Especially in other than $PGDATA, read-only, and otherwise stateless
      containers, it could be annoying to change passwords and provision users,
      and you won't be able to change them over time.
    query: |
      SELECT *
      FROM pg_catalog.pg_hba_file_rules
      WHERE auth_method IN ('pam', 'bsd')
      ORDER BY line_number

  no-columns:
    severity: error
    title: Tables without columns
    labels:
      - cosmetic
      - minor
    comment: We do not care for “table dual”, use (SELECT); then.
    query: |
      SELECT tables.table_schema, tables.table_name
      FROM information_schema.tables
      LEFT JOIN information_schema.columns
        ON (tables.table_schema, tables.table_name) =
           (columns.table_schema, columns.table_name)
      GROUP BY tables.table_schema, tables.table_name
      HAVING count(columns.table_name) = 0
      ORDER BY tables.table_schema, tables.table_name

  one-column:
    severity: warning
    title: Tables with just one column
    labels:
      - hitandmiss
      - correctness
      # Not committing to major or minor. Highly variable impact. Should we
      # just have a "variable" impact?
    comment: May conflict with pseudo-enums, fake tables, etc.
    query: |
      SELECT table_schema, table_name
      FROM information_schema.columns
      WHERE table_schema = 'public'
      GROUP BY table_schema, table_name
      HAVING count(*) = 1
      ORDER BY table_schema, table_name

  all-nullable:
    severity: warning
    title: All non-PK columns nullable
    labels:
      - hitandmiss
      - correctness
      # - variable
    # FIXME: Doesn't handle multicolumn PKs, e.g., on some join tables.
    query: |
      SELECT *
      FROM (
        SELECT columns.table_schema, columns.table_name,
               count(columns.column_name)
                 FILTER (WHERE ccu IS NULL AND
                               is_nullable = 'YES')
                 AS nonpk_nullable,
               count(columns.column_name) AS columns,
               count(columns.column_name)
                 FILTER (WHERE ccu IS NOT NULL)
                 AS pk_columns
        FROM information_schema.columns
        JOIN information_schema.tables
          ON (columns.table_schema, columns.table_name) =
             (tables.table_schema, tables.table_name) AND
             tables.table_type = 'BASE TABLE' AND
             tables.table_schema = 'public'
        LEFT JOIN information_schema.table_constraints
          AS tc
          ON (columns.table_schema, columns.table_name) =
             (tc.table_schema, tc.table_name) AND
             tc.constraint_type = 'PRIMARY KEY'
        LEFT JOIN information_schema.constraint_column_usage
          AS ccu
          ON (ccu.table_schema, ccu.table_name, ccu.column_name,
              ccu.constraint_name) =
             (columns.table_schema, columns.table_name, columns.column_name,
              tc.constraint_name)
        GROUP BY columns.table_schema, columns.table_name
      ) AS cc
      WHERE columns - nonpk_nullable = pk_columns AND
            nonpk_nullable > 0

  # TODO: Introduce Python-side matches?

  primary-key-not-first:
    # FIXME: Doesn't deal well with dropped columns.
    severity: notice
    title: Primary key column not first column
    labels:
      - cosmetic
      - minor
    comment: May interfere with column Tetris
    query: |
      SELECT table_schema, table_name,
             array_agg(column_name ORDER BY ordinal_position)
               AS column_names,
             array_agg(ordinal_position ORDER BY ordinal_position)
               AS ordinal_positions
      FROM (
        SELECT c.table_schema, c.table_name, c.column_name, c.ordinal_position,
              count(*) OVER w
        FROM information_schema.columns
          AS c
        JOIN information_schema.table_constraints
          AS tc
          ON (c.table_schema, c.table_name) =
            (tc.table_schema, tc.table_name) AND
            tc.constraint_type = 'PRIMARY KEY'
        JOIN information_schema.constraint_column_usage
          AS ccu
          ON (ccu.table_schema, ccu.table_name, ccu.column_name,
              ccu.constraint_name) =
            (c.table_schema, c.table_name, c.column_name,
              tc.constraint_name)
        -- Cannot bool_or(ordinal_position > count(*)) because it's nested.
        -- Don't want to just look at count(*) = 1.
        WINDOW w AS (PARTITION BY c.table_schema, c.table_name)
        ORDER BY 1, 2
      ) AS pks
      WHERE ordinal_position > count
      GROUP BY table_schema, table_name

  no-primary-key:
    severity: warning
    title: Tables without a primary key
    labels:
      - probable
      # - variable
      - correctness
    query: |
      SELECT DISTINCT table_schema, table_name
      FROM information_schema.tables
      WHERE table_schema <> 'information_schema' AND
            table_schema NOT LIKE 'pg%' AND
            table_type = 'BASE TABLE' -- Or <> 'VIEW'?
      EXCEPT ALL
      SELECT table_schema, table_name
      FROM information_schema.table_constraints
      WHERE constraint_type = 'PRIMARY KEY'
      ORDER BY table_schema, table_name

  non-generated-pk:
    severity: warning
    title: Tables where primary key is DEFAULT instead of GENERATED
    labels:
      - hitandmiss
      - correctness
    query: |
      SELECT columns.table_schema, columns.table_name, column_default
      FROM information_schema.columns
      JOIN information_schema.table_constraints
        ON (columns.table_schema, columns.table_name) =
           (table_constraints.table_schema, table_constraints.table_name) AND
           constraint_type = 'PRIMARY KEY'
      JOIN information_schema.constraint_column_usage
        AS ccu
        ON (ccu.table_schema, ccu.table_name, ccu.column_name,
            ccu.constraint_name) =
           (columns.table_schema, columns.table_name, columns.column_name,
            table_constraints.constraint_name)
      WHERE is_generated = 'NEVER' AND column_default IS NOT NULL
      ORDER BY 1, 2, 3

  non-always-pk:
    severity: warning
    title: Tables where primary key is GENERATED BY DEFAULT instead of ALWAYS
    labels:
      - correctness
      - subjective
    query: |
      SELECT columns.table_schema, columns.table_name, columns.column_name,
             columns.identity_generation
      FROM information_schema.columns
      JOIN information_schema.table_constraints
        ON (columns.table_schema, columns.table_name) =
           (table_constraints.table_schema, table_constraints.table_name) AND
           constraint_type = 'PRIMARY KEY'
      JOIN information_schema.constraint_column_usage
        AS ccu
        ON (ccu.table_schema, ccu.table_name, ccu.column_name,
            ccu.constraint_name) =
           (columns.table_schema, columns.table_name, columns.column_name,
            table_constraints.constraint_name)
      WHERE identity_generation <> 'ALWAYS'
      ORDER BY 1, 2, 3

  non-bigint-pk:
    severity: error
    title: Integer PK is not bigint
    labels:
      - correctness
      - subjective
    comment: |
      Your number of rows matters not. It's the total lifetime of the
      application divided by the row churn.
    query: |
      SELECT c.table_schema, c.table_name, c.column_name,
             c.data_type, c.udt_name
      FROM information_schema.columns
        AS c
      JOIN information_schema.table_constraints
        AS tc
        ON (c.table_schema, c.table_name) =
          (tc.table_schema, tc.table_name) AND
          tc.constraint_type = 'PRIMARY KEY'
      JOIN information_schema.constraint_column_usage
        AS ccu
        ON (ccu.table_schema, ccu.table_name, ccu.column_name,
            ccu.constraint_name) =
          (c.table_schema, c.table_name, c.column_name,
            tc.constraint_name)
      WHERE c.numeric_precision IS NOT NULL AND
            c.data_type <> 'bigint'
      ORDER BY 1, 2, 3

  inconsistent-surrogate-pk-types:
    severity: notice
    title: Inconsistent surrogate PK types with a GENERATED/IDENTITY/DEFAULT
    labels:
      - correctness
      - consistency
    query: |
        SELECT count(*) AS pk_types,
               jsonb_object_agg(udt_name, count) AS udt_counts
        FROM (
          SELECT udt_name, count(*)
          FROM information_schema.columns
            AS c
          JOIN information_schema.table_constraints
            AS tc
            ON (c.table_schema, c.table_name) =
              (tc.table_schema, tc.table_name) AND
              tc.constraint_type = 'PRIMARY KEY'
          JOIN information_schema.constraint_column_usage
            AS ccu
            ON (ccu.table_schema, ccu.table_name, ccu.column_name,
                ccu.constraint_name) =
              (c.table_schema, c.table_name, c.column_name,
                tc.constraint_name)
          WHERE c.is_identity = 'YES' OR c.column_default IS NOT NULL
          GROUP BY c.udt_name
        ) q
        HAVING count(DISTINCT udt_name) > 1

  inconsistent-db-side-client-side-timestamps:
    severity: warning
    title:
      Tables where created_at is sometimes but not always a DEFAULT/GENERATED
    labels:
      - correctness
      - consistency
    query: |
      SELECT columns.column_name, columns.table_schema, columns.table_name,
             column_default
      FROM information_schema.columns
      JOIN (
        SELECT column_name
        FROM information_schema.columns
        WHERE column_name IN ('created_at', 'updated_at')
        GROUP BY column_name
        HAVING count(DISTINCT column_default) > 1
      ) AS mixed ON columns.column_name = mixed.column_name
      ORDER BY 1, 2, 3

  no-pg-rules:
    severity: warning
    title: Use of PostgreSQL RULEs
    labels:
      - proprietary
      - postgres
      - deprecations
    query: |
      SELECT schemaname, tablename, rulename
      FROM pg_catalog.pg_rules
      WHERE schemaname NOT LIKE 'pg%'
      ORDER BY schemaname, tablename, rulename

  no-pg-inheritance:
    severity: warning
    title: Use of PostgreSQL inheritance
    labels:
      - proprietary
      - postgres
      - deprecations
    query: |
      SELECT parent_ns.nspname AS parent_ns, parent.relname AS parent,
            child_ns.nspname AS child_ns, child.relname AS child
      FROM pg_inherits
      JOIN pg_class AS parent ON inhparent = parent.oid
      JOIN pg_class AS child ON inhrelid = child.oid
      JOIN pg_namespace AS parent_ns ON parent.relnamespace = parent_ns.oid
      JOIN pg_namespace AS child_ns ON child.relnamespace = child_ns.oid
      ORDER BY parent_ns.nspname, parent.relname, inhseqno;

  server-encoding:
    severity: error
    title: Non-UTF8 server encoding
    labels:
      - server
      - proprietary
      - postgres
    comment: |
      https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_SQL_ASCII
    query: |
      SELECT *
      FROM pg_settings
      WHERE name = 'server_encoding' AND
            NOT setting LIKE 'UTF8%'

  # See also:
  # SELECT name, setting, boot_val, reset_val
  # FROM pg_settings
  # WHERE setting <> reset_val OR boot_val <> reset_val;
  server-settings:
    severity: error
    title: Inarguably insufficient server settings
    labels:
      - server
      - proprietary
      - postgres
    query: |
      SELECT pg_settings.name, pg_settings.setting,
             better.new AS better, reason
      FROM pg_catalog.pg_settings
      JOIN (VALUES ('password_encryption', 'md5', 'scram-sha-256',
                    'Not cryptographically broken hash'),
                   ('data_checksums', 'off', 'on', 'Data integrity'))
        AS better(name, old, new, reason)
        ON pg_settings.name = better.name AND pg_settings.setting = old
      ORDER BY name

  # TODO: Sub in as params intead of hardcoding, so that people can add more
  # better defaults, but we'd have to use YAML extensions to cast to tuple so
  # it subs in as the right syntax, or just always use tuples for all
  # queries.
  better-defaults:
    severity: error
    title: Columns that could have better defaults
    labels:
      - correctness
    query: |
      SELECT table_schema, table_name, column_name, column_default,
             new AS better_default, reason
      FROM information_schema.columns
      JOIN (VALUES ('now()',
                    'CURRENT_TIMESTAMP',
                    'the former is PG-specific, the latter standard'),
                   ('CURRENT_TIME',
                    'CURRENT_TIMESTAMP',
                    'the former is not zone-aware'),
                   ('nextval(%',
                    'GENERATED ALWAYS AS IDENTITY',
                    'the former is accidentally overrideable, not standard,'
                    ' annoying to manage (need to know the sequence name),'
                    ' etc.'))
        AS betters(old, new, reason)
        ON btrim(column_default) LIKE betters.old
      WHERE table_schema = 'public'
      ORDER BY 1, 2, 3, 4

  # TODO: Not use pg_statio_all_tables.
  uncommented-columns:
    severity: notice
    title: Columns without a COMMENT (description)
    labels:
      - cosmetic
    query: |
      SELECT st.relname AS table_name,
             c.column_name
      FROM pg_catalog.pg_statio_all_tables
          AS st
      INNER JOIN information_schema.columns
          AS c
          ON c.table_schema = st.schemaname AND
             c.table_name = st.relname AND
             c.table_schema = 'public'
      LEFT OUTER JOIN pg_catalog.pg_description
          AS pgd
          ON pgd.objoid = st.relid AND
             pgd.objsubid = c.ordinal_position
      WHERE nullif(btrim(pgd.description), '') IS NULL
      ORDER BY st.relname, c.ordinal_position

  #redundant-indicies:
  #  severity: warning
  #  query: TODO

  #redundant-uniques:
  #  severity: warning
  #  query: TODO

  column-counts:
    severity: info
    title: Number of columns in each table
    labels:
      - correctness
      - performance
    comment: |
      If you have many, your table is unwieldy for UPDATEs (especially if only
      updating a few columns), there's a lot of per-row overhead in the NULL
      bitmask, and in general, it's a bit harder to understand.
    query: |
      SELECT table_name, count(*)
      FROM information_schema.columns
      WHERE table_schema = 'public' AND
            table_catalog = 'api'
      GROUP BY table_name
      ORDER BY table_name

  imagined-id-defaults:
    severity: warning
    title: Imagined ID columns that have a default value
    labels:
      - correctness
    comment: |
      IDs SHOULD NOT have default values, whether primary keys or foreign keys
      (enforced or not).
    query: |
      SELECT table_name, column_name, column_default, is_nullable, data_type
      FROM information_schema.columns
      WHERE column_name LIKE '%\_id' AND
            column_default IS NOT NULL
      ORDER BY table_name, column_name

  nullable-defaults:
    severity: error
    title: NULLable columns with default values
    labels:
      - correctness
    comment: |
      Either you should be NULLable and have no default value,
      or you should have a default value and not be NULLable.
      If you do anything else, you probably have a bad type or relation design.
    query: |
      SELECT table_name, column_name, data_type, column_default
      FROM information_schema.columns
      WHERE is_nullable = 'YES' AND
            column_default IS NOT NULL
      ORDER BY table_name, column_name

  # Not typical. Really only seen in two 3rd party projects.
  unenforced-foreign-keys:
    severity: error
    title: Imagined FK columns, and maybe their polymorphic type column
    labels:
      - correctness
    comment: |
      What the heck. Seriously‽ It's NOT debatable whether to enforce foreign
      keys.
      It completely misses the point to not enforce. “Relational” DB much?
      Always.
      And you cannot do app-side concurrency. Don't even try.
      You are in all likelihood not qualified to do it performantly or
      correctly.
      It takes years and the right training, exposure, and literature to be so.
      And yes, polymorphic associations can have referential integrity,
      even if they have different sequences.
    query: |
      SELECT columns.table_name,
            columns.column_name,
            type_columns.column_name AS type_column,
            columns.is_nullable,
            columns.column_default
      FROM information_schema.columns
      LEFT OUTER JOIN information_schema.key_column_usage
          ON columns.column_name = key_column_usage.column_name
      LEFT OUTER JOIN information_schema.columns
          AS type_columns
          ON (columns.table_schema,
              columns.table_name,
              regexp_replace(columns.column_name, '_id$', '_type')) =
            (type_columns.table_schema,
              type_columns.table_name,
              type_columns.column_name)
      WHERE columns.table_schema = 'public' AND
            columns.column_name LIKE '%\_id' AND
            key_column_usage.column_name IS NULL
      ORDER BY columns.table_name, columns.column_name

  non-unique-foreign-keys:
    severity: warning
    title: Real or imagined FK columns that not in a UNIQUE constraint
    labels:
      - correctness
    query: |
      SELECT columns.table_name,
             columns.column_name
      FROM information_schema.columns
      LEFT OUTER JOIN information_schema.key_column_usage
          ON columns.column_name = key_column_usage.column_name
      LEFT OUTER JOIN information_schema.columns
          AS type_columns
          ON (columns.table_schema,
              columns.table_name,
              regexp_replace(columns.column_name, '_id$', '_type')) =
             (type_columns.table_schema,
              type_columns.table_name,
              type_columns.column_name)
      LEFT OUTER JOIN information_schema.constraint_column_usage
          ON (columns.table_schema,
              columns.table_name,
              columns.column_name) =
             (constraint_column_usage.table_schema,
              constraint_column_usage.table_name,
              constraint_column_usage.column_name)
      WHERE columns.table_schema = 'public' AND
            (columns.column_name LIKE '%\_id' OR
             key_column_usage.position_in_unique_constraint IS NOT NULL)
      GROUP BY columns.table_name, columns.column_name
      HAVING count(constraint_column_usage.constraint_name) = 0
      ORDER BY columns.table_name, columns.column_name

  multicolumn-indexes:
    severity: info
    title: Multicolumn indexes, their columns, and their stats
    labels:
      - performance
    comment: |
      Gotta inspect that index column order for appropriateness to usage.
      Purely sequential scans with a large enough dataset can be an
      indication of bad column order. See article on “Use the Index Luke”.
      Even nonzero index scan count can still mean the order is suboptimal,
      and that you're not optimising for the right case.
      You have to consider though if you change the order overall if the app
      performance is sufficient.
    query: |
      SELECT table_class.relname AS table_name,
             index_class.relname AS index_name,
             array_agg(pg_attribute.attname
                       ORDER BY pg_index.indkey) AS columns,
             min(seq_scan) AS seq_scan,
             min(seq_tup_read) AS seq_tup_read,
             min(idx_scan) AS idx_scan,
             min(idx_tup_fetch) AS idx_tup_fetch
      FROM pg_index
      INNER JOIN pg_class
          AS table_class
          ON table_class.oid = pg_index.indrelid
      INNER JOIN pg_class
          AS index_class
          ON index_class.oid = pg_index.indexrelid
      INNER JOIN pg_attribute
          ON pg_attribute.attrelid = table_class.oid AND
             pg_attribute.attnum = ANY(pg_index.indkey)
      INNER JOIN pg_namespace
          ON table_class.relnamespace = pg_namespace.oid
      INNER JOIN pg_stat_user_tables
          ON pg_stat_user_tables.relid = table_class.oid
      WHERE pg_namespace.nspname = 'public'
      GROUP BY table_name, index_name
      HAVING count(*) > 1
      ORDER BY table_name, index_name

  unused-indexes:
    severity: warning
    title: Never used indexes
    labels:
      - performance
    query: |
      SELECT relname, indexrelname
      FROM pg_stat_user_indexes
      WHERE idx_scan = 0 AND
            idx_tup_read = 0 AND
            idx_tup_fetch = 0 AND
            schemaname = 'public'
      ORDER BY relname, indexrelname

  forbidden-types:
    severity: error
    title: Forbidden data types
    labels:
      - correctness
    comment: |
      In particular:

      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_char.28n.29_even_for_fixed-length_identifiers
      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_money
      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_timestamp_.28without_time_zone.29
      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_timestamp_.28without_time_zone.29_to_store_UTC_times
      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_timetz
      - https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_timestamp.280.29_or_timestamptz.280.29
    params:
      data_types:
        - character
        - money
        - time with time zone
        - timestamp without time zone
      data_types_extra: []
      udt_names: []
      data_types_not: []
      udt_names_not: []
    query: |
      SELECT table_name, column_name, data_type, udt_name
      FROM information_schema.columns
      WHERE table_schema = 'public' AND
            (data_type = ANY(%(data_types)s) OR
             data_type = ANY(%(data_types_extra)s) OR
             udt_name = ANY(%(udt_names)s)) AND
            NOT (data_type = ANY(%(data_types_not)s) OR
                 udt_name = ANY(%(udt_names_not)s))
      ORDER BY table_name, column_name

  warning-types:
    severity: warning
    title: Discouraged data types
    labels:
      - correctness
    comment: |
      In particular:

      - Unless preserving key order or redundant keys, JSONB is preferred over
        JSON, and has been for a few major releases.
      - Don't use internal PG types if possible.
    params:
      data_types:
        - character varying
        - ARRAY
        - anyarray
        - anyc
      udt_names: []
      data_types_not: []
      udt_names_not: []
      allow_pg_internal: false
    query: |
      SELECT table_schema, table_name, column_name, data_type, udt_name
      FROM information_schema.columns
      WHERE table_schema = 'public' AND

            ((data_type = ANY(%(data_types)s) OR
              udt_name = ANY(%(udt_names)s)) AND
             NOT (data_type = ANY(%(data_types_not)s) OR
                  udt_name = ANY(%(udt_names_not)s)) OR

             NOT %(allow_pg_internal)s AND data_type LIKE 'pg_%%')
      ORDER BY table_name, column_name

  varchar-silent-truncation:
    severity: notice
    title: VARCHAR(n) will silently truncate oversized inputs
    labels:
      - correctness
    comment: |
      Consider TEXT instead, or make sure you have proper truncation
      detection/warnings/errors client-side. VARCHAR(n) is OK if you explicitly
      need to be robust against oversized inputs and you are OK with the lack
      of warnnig.
    query:
      SELECT table_schema, table_name, column_name, character_maximum_length
      FROM information_schema.columns
      WHERE character_maximum_length IS NOT NULL AND
            table_schema = 'public'
      ORDER BY 1, 2, 3

  nullable-columns:
    severity: error
    title: Columns that are NULLable
    labels:
      - correctness
    params:
      # E.g., ['table_with_external_data_lotsa_nulls']
      tables: []
      # E.g., ['updated_at'], which is a bad idea anyway.
      columns: []
      # E.g.,
      #   - ['users', 'phone_number']
      #   - ['one', 'more']
      #   - ['table', 'column']
      table_columns: []
    query: |
      SELECT table_name, column_name
      FROM information_schema.columns
      WHERE table_schema = 'public' AND
            is_nullable = 'YES' AND
            NOT table_name = ANY(%(tables)s) AND
            NOT (table_name, column_name) = ANY(%(table_columns)s) AND
            NOT (table_name, column_name) = ANY(%(table_columns)s)
      ORDER BY table_name, column_name

  # TODO: Unused indexes, row size descriptive stats.

  foreign-keys-with-defaults:
    severity: error
    title: FK columns with a default value
    labels:
      - correctness
    comment: |
      Probably wrong or brittle, other than requiring seed data, assuming
      hardcoded IDs in seed data, or that you use semantic keys.
    query: |
      SELECT columns.table_name,
            columns.column_name,
            columns.is_nullable,
            columns.column_default
      FROM information_schema.columns
      INNER JOIN information_schema.key_column_usage
          ON columns.column_name = key_column_usage.column_name AND
            key_column_usage.position_in_unique_constraint IS NOT NULL
      WHERE columns.table_schema = 'public' AND
            columns.column_default IS NOT NULL
      ORDER BY columns.table_name, columns.column_name

  nullable-keys:
    severity: warning
    title:
      Foreign keys where at least one of either the referencing or referenced
      columns is nullable
    labels:
      - correctness
    comment: |
      This isn't always bad, but we do want to check all of these cases.
      There have definitely been some incorrect ones found this way.
      Warn by default for now. Walk it back later.
    query: |
      SELECT min(kcu1.table_name) AS referencing_table,
            array_agg(kcu1.column_name::text) AS referencing_columns,
            min(kcu2.table_name) AS referenced_table,
            array_agg(kcu2.column_name::text) AS referenced_columns,
            rc.constraint_name AS constraint_name,
            array_agg(referencing_columns.column_name)
              FILTER (WHERE referencing_columns.is_nullable = 'YES')
              AS referencing_nullable,
            array_agg(referenced_columns.column_name)
              FILTER (WHERE referenced_columns.is_nullable = 'YES')
              AS referenced_nullable
      FROM information_schema.key_column_usage
        AS kcu1
      INNER JOIN information_schema.referential_constraints
        AS rc
        ON kcu1.constraint_name = rc.constraint_name
      INNER JOIN information_schema.key_column_usage
        AS kcu2
        ON rc.unique_constraint_name = kcu2.constraint_name
      INNER JOIN information_schema.columns
        AS referencing_columns
        ON referencing_columns.table_name = kcu1.table_name AND
          referencing_columns.column_name = kcu1.column_name
      INNER JOIN information_schema.columns
        AS referenced_columns
        ON referenced_columns.table_name = kcu2.table_name AND
          referenced_columns.column_name = kcu2.column_name
      GROUP BY rc.constraint_name
      HAVING bool_or(referencing_columns.is_nullable = 'YES') OR
            bool_or(referenced_columns.is_nullable = 'YES')
      ORDER BY referencing_table, constraint_name

  multicolumn-unique-nullable:
    severity: warning
    title: UNIQUE constraints where at least one of the columns is NULLable
    labels:
      - correctness
      - hitandmiss
    comment: |
      This can bad because you can have practical duplicates if any of these
      columns is NULLable.
    query: |
      SELECT table_constraints.constraint_name,
             array_agg(columns.column_name) AS nullable_columns
      FROM information_schema.table_constraints
      INNER JOIN information_schema.key_column_usage
        ON table_constraints.constraint_name = key_column_usage.constraint_name
      INNER JOIN information_schema.columns
        ON key_column_usage.table_name = columns.table_name AND
           key_column_usage.column_name = columns.column_name
      WHERE constraint_type = 'UNIQUE' AND
            is_nullable = 'YES'
      GROUP BY table_constraints.table_name,
               table_constraints.constraint_name
      ORDER BY table_constraints.table_name,
               table_constraints.constraint_name

  self-referential-table:
    severity: notice
    title: Self-referential table
    labels:
      - performance
    comment: |
      Possibly not what you want. Depends on your tree or other datastructure
      design pattern.
    query: |
      SELECT fkey.table_schema, fkey.table_name, fkey.constraint_name
      FROM information_schema.referential_constraints
        AS rc
      JOIN information_schema.table_constraints
        AS fkey
        ON (fkey.constraint_schema, fkey.constraint_name) =
           (rc.constraint_schema, rc.constraint_name)
      JOIN information_schema.table_constraints
        AS pkey
        ON (pkey.constraint_schema, pkey.constraint_name) =
           (rc.unique_constraint_schema, rc.unique_constraint_name)
      WHERE (fkey.table_schema, fkey.table_name) =
            (pkey.table_schema, pkey.table_name)
      ORDER BY 1, 2, 3

  disconnected-tables:
    severity: notice
    title: Tables without a reference to at least another one
    labels:
      - correctness
    query: |
      SELECT tables.table_schema, tables.table_name
      FROM information_schema.tables
      LEFT JOIN information_schema.table_constraints
        AS tc
        ON (tables.table_schema, tables.table_name) =
           (tc.table_schema, tc.table_name) AND
           tc.constraint_type = 'FOREIGN KEY'
      WHERE tc IS NULL AND tables.table_schema = 'public'
      ORDER BY 1, 2

  forbidden-routine-language:
    severity: error
    title: Forbidden procedure/function language
    labels:
      - controversial
      - imrsv
    query: |
      SELECT routine_schema, routine_name, routine_type, external_language
      FROM information_schema.routines
      WHERE external_language NOT IN ('SQL', 'PLPGSQL', 'C', 'INTERNAL')
      ORDER BY 1, 2, 3, 4

  forbidden-extension:
    severity: error
    title: Forbidden PostgreSQL extension
    labels:
      - proprietary
      - postgres
      - security
      - controversial
      - imrsv
    query: |
      SELECT pg_namespace.nspname, pg_extension.extname, v.why
      FROM pg_catalog.pg_extension
      JOIN pg_namespace
        ON pg_namespace.oid = pg_extension.extnamespace
      JOIN (VALUES ('plpythonu',
                    'Should be explicit about Python 2 vs 3 rather than'
                    ' depending on the cloud or Linux distro'),
                   ('plpython2u',
                    'You really should have left in 2015, and it was finally'
                    ' dead for real in Jan 2020'),
                   ('pltcl',
                    'Tcl has long been an inferior language to Python, aside'
                    ' from Expect. Please don''t.'),
                   ('pltclu',
                    'Tcl has long been an inferior language to Python, aside'
                    ' from Expect. Please don''t.'),
                   ('plperl',
                    'Please don''t write in a "write-only" language like Perl'
                    ' that nobody at IMRSV knows.'),
                   ('plperlu',
                    'Please don''t write in a "write-only" language like Perl'
                    ' that nobody at IMRSV knows.'),
                   ('file_fdw',
                    'You shouldn''t have to deal with and lock down anything'
                    ' but the PG protocol, especially in read-only other'
                    ' than $PGDATA stateless containers. It''s also'
                    ' probably not available on the cloud.'),
                   ('adminpack',
                    'You shouldn''t have to deal with and lock down anything'
                    ' but the PG protocol, especially in read-only other'
                    ' than $PGDATA stateless containers. It''s also'
                    ' probably not available on the cloud.'),
                   ('test_decoding',
                    'Is example source code only!'))
        AS v(extname, why)
        ON pg_extension.extname = v.extname
      ORDER BY 1, 2

  deprecated-extension:
    severity: warning
    title: Deprecated PostgreSQL extension
    labels:
      - proprietary
      - postgres
      - correctness
    query: |
      SELECT pg_namespace.nspname, pg_extension.extname, v.why
      FROM pg_catalog.pg_extension
      JOIN pg_namespace
        ON pg_namespace.oid = pg_extension.extnamespace
      JOIN (VALUES ('uuid-ossp',
                    'Do you really need anything but UUIDv4?'),
                   ('xml2',
                    'Per v14 F.45 § F.45.1 Deprecation Notice, use the SQL'
                    ' standard instead'),
                   ('dblink',
                    'Inconvenient, especially compared to postgres_fdw'),
                   ('hstore',
                    'You can probably just use jsonb'),
                   ('intagg',
                    'Per v14 F.17, "The intagg module provides an integer'
                    ' aggregator and an enumerator. intagg is now obsolete,'
                    ' because there are built-in functions that provide a'
                    ' superset of its capabilities. However, the module is'
                    ' still provided as a compatibility wrapper around the'
                    ' built-in functions."'))
        AS v(extname, why)
        ON pg_extension.extname = v.extname
      ORDER BY 1, 2
